Problem ID,Thinking,Coding,LeetCode Tags,Tags,Runtime,Space,Variables,Notes
count-substrings-that-satisfy-k-constraint-i,5,5,String|Sliding Window,,$N$,$1$,$N$ = length of $s$,
lucky-numbers-in-a-matrix,5,2,Array|Matrix,,$N \cdot M$,$N \cdot M$,$N$ = number of rows|$M$ = number of columns,
percentage-of-letter-in-string,1,2,String,,$N$,$1$,$N$ = length of $s$,
rearrange-characters-to-make-target-string,2,2,Hash Table|String|Counting,,$N+M$,$1$,$N$ = length of $s$|$M$ = length of $target$,
split-the-array,2,2,Array|Hash Table|Counting,Parity,$N$,$N$,$N$ = length of $nums$,
divide-an-array-into-subarrays-with-minimum-cost-i,2,2,Array|Sorting|Enumeration,,$N$,$1$,$N$ = length of $nums$,
longest-common-prefix,1,2,String|Trie,,$N \cdot M$,$M$,$N$ = length of $strs$|$M$ = length of prefix,
alternating-digit-sum,1,2,Math,,$\log(N)$,$1$,,
pascals-triangle,2,5,Array|Dynamic Programming,,$N^2$,$N^2$,$N$ = $numRows$,
count-integers-with-even-digit-sum,5,5,Math|Simulation,,$\log(N)$,$1$,,
lowest-common-ancestor-of-a-binary-tree,2,10,Tree|Depth-First Search|Binary Tree,,$D$,$N$,$D$ = depth of the tree|$N$ = number of nodes,
maximum-product-after-k-increments,2,2,Array|Greedy|Heap (Priority Queue),,$K \cdot \log(N)$,$N$,$N$ = length of $nums$,
number-of-ways-to-select-buildings,5,5,String|Dynamic Programming|Prefix Sum,Markov Model,$N$,$1$,$N$ = length of $s$,
kth-missing-positive-number,15,10,Array|Binary Search,,$\log(N)$,$1$,$N$ = length of $arr$,
shortest-subarray-with-sum-at-least-k,15,10,Array|Binary Search|Queue|Sliding Window|Heap (Priority Queue)|Prefix Sum|Monotonic Queue,,$N$,$N$,$N$ = length of $nums$,
special-array-ii,5,10,Array|Binary Search|Prefix Sum,,$N+Q \cdot \log(N)$,$N$,$N$ = length of $nums$|$Q$ = length of $queries$,
knight-dialer,5,15,Dynamic Programming,Markov Model,$\log(N)$,$1$,,"There is inflated time on the Coding score because of the need to code your own matrix power and matrix multiplication with modulos. Otherwise, the score would be 5."
number-of-ways-to-paint-n-3-grid,5,15,Dynamic Programming,Markov Model,$\log(N)$,$1$,,"There is inflated time on the Coding score because of the need to code your own matrix power and matrix multiplication with modulos. Otherwise, the score would be 5."
reverse-prefix-of-word,1,2,Two Pointers|String|Stack,,$N$,$N$,$N$ = length of $word$,
check-if-one-string-swap-can-make-strings-equal,1,2,Hash Table|String|Counting,,"$\min(N,M)$",$1$,$N$ = length of s1|$M$ = length of $s2$,
make-string-a-subsequence-using-cyclic-increments,1,2,Two Pointers|String,,$N$,$1$,$N$ = length of $str1$,
minimum-difference-in-sums-after-removal-of-elements,15,10,Array|Dynamic Programming|Heap (Priority Queue),,$N \cdot \log(N)$,$N$,$N$ = length of $nums$,
copy-list-with-random-pointer,1,5,Hash Table|Linked List,,$N$,$N$,$N$ = number of nodes,
max-dot-product-of-two-subsequences,5,10,Array|Dynamic Programming,,$N \cdot M$,"$\min(N,M)$",$N$ = length of nums1|$M$ = length of $nums2$,
maximum-score-after-splitting-a-string,1,2,String|Prefix Sum,,$N$,$1$,$N$ = length of $string$,
minimum-cost-for-tickets,2,5,Array|Dynamic Programming,,$N$,$N$,$N$ = number of days,
largest-number,5,5,Array|String|Greedy|Sorting,,$N \cdot \log(N)$,$N$,$N$ = length of $nums$,
two-best-non-overlapping-events,5,5,Array|Binary Search|Dynamic Programming|Sorting|Heap (Priority Queue),,$N \cdot \log(N)$,$N$,$N$ = number of events,
number-of-ways-to-form-a-target-string-given-a-dictionary,2,10,Array|String|Dynamic Programming,,$M \cdot (N+K)$,$K$,$N$ = length of words|$M$ = length of each word|$K$ = length of $target$,
number-of-ways-to-split-array,2,2,Array|Prefix Sum,,$N$,$1$,$N$ = length of $nums$,
n-queens,2,5,Array|Backtracking,,$N!$,$N! \cdot N^2$,,
sort-colors,1,2,Array|Two Pointers|Sorting,,$N$,$1$,$N$ = length of $nums$,
shifting-letters-ii,5,5,Array|String|Prefix Sum,,$N+M$,$N$,$N$ = length of s|$M$ = length of $shifts$,
minimum-number-of-operations-to-move-all-balls-to-each-box,5,5,Array|String|Prefix Sum,,$N$,$1$,$N$ = length of $boxes$,
n-queens-ii,2,5,Backtracking,,$N!$,$N^2$,,
regular-expression-matching,5,10,String|Dynamic Programming|Recursion,,$N^3 \cdot M$,$N$,$N$ = length of s|$M$ = length of $p$,
container-with-most-water,10,5,Array|Two Pointers|Greedy,,$N$,$1$,$N$ = length of $height$,
integer-to-roman,2,5,Hash Table|Math|String,,$\log(N)$,$1$,$N$ = $num$,
stone-game,2,1,Array|Math|Dynamic Programming|Game Theory,,$N \cdot \log(N)$,$N$,$N$ = length of $piles$,
stone-game-vi,10,5,Array|Math|Greedy|Sorting|Heap (Priority Queue)|Game Theory,,$N \cdot \log(N)$,$N$,$N$ = length of $aliceValues$,
stone-game-ii,5,5,Array|Math|Dynamic Programming|Prefix Sum|Game Theory,,$N^3$,$N$,$N$ = length of $piles$,
stone-game-iii,5,5,Array|Math|Dynamic Programming|Game Theory,,$N$,$N$,$N$ = length of $stoneValue$,
stone-game-iv,5,2,Math|Dynamic Programming|Game Theory,,$N$,$N$,,
stone-game-v,5,10,Array|Math|Dynamic Programming|Game Theory,,$N^3$,$N^2$,$N$ = length of $stoneValue$,"There is also a quadratic time solution, but that would probably take around 60 minutes of thinking and 15 minutes of coding."
stone-game-vii,5,5,Array|Math|Dynamic Programming|Game Theory,,$N^3$,$N$,$N$ = length of $stones$,
roman-to-integer,1,2,Hash Table|Math|String,,$N$,$1$,$N$ = length of $s$,
letter-combinations-of-a-phone-number,1,5,Hash Table|String|Backtracking,,$4^N$,$N \cdot 4^N$,$N$ = length of $digits$,
remove-nth-node-from-end-of-list,2,2,Linked List|Two Pointers,,$N$,$1$,$N$ = number of nodes,
valid-parentheses,2,2,String|Stack,,$N$,$N$,$N$ = length of $s$,
generate-parentheses,2,2,String|Dynamic Programming|Backtracking,,$N \cdot C_N$,$N \cdot C_N$,$C_n$ = the $n$th Catalan number,
swap-nodes-in-pairs,1,2,Linked List|Recursion,,$N$,$1$,$N$ = number of nodes,
remove-duplicates-from-sorted-array,1,2,Array|Two Pointers,,$N$,$1$,$N$ = length of $nums$,
remove-element,1,2,Array|Two Pointers,,$N$,$1$,$N$ = length of $nums$,
valid-sudoku,1,5,Array|Hash Table|Matrix,,$N^2$,$N$,$N$ = $9$,
powx-n,5,1,Math|Recursion,Fundamental,$\log(N)$,$1$,,
sqrtx,5,2,Math|Binary Search,,$\log(X)$,$1$,,
merge-k-sorted-lists,2,5,Linked List|Divide and Conquer|Heap (Priority Queue)|Merge Sort,,$N\cdot \log(T)$,$N$,$N$ = length of $lists$|$T$ = total number of nodes,
candy,5,2,Array|Greedy,,$N$,$N$,$N$ = length of $ratings$,
group-anagrams,1,2,Array|Hash Table|String|Sorting,,$T$,$T$,$T$ = total length of strings,
